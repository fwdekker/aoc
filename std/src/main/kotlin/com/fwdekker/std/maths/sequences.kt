@file:Suppress("unused")

package com.fwdekker.std.maths

import java.math.BigInteger


/**
 * Returns an infinite sequence of all natural numbers, beginning at [start].
 */
fun naturalNumbersInt(start: Int = 0): Sequence<Int> =
    generateSequence(start) { it.inc() }

fun naturalNumbersLong(start: Long = 0L): Sequence<Long> =
    generateSequence(start) { it.inc() }

fun naturalNumbersBigInt(start: BigInteger = BigInteger.ZERO): Sequence<BigInteger> =
    generateSequence(start) { it.inc() }


/**
 * Returns an infinite sequence of Fibonacci numbers, starting with 1, 1, 2.
 */
fun fibonacciNumbersInt(): Sequence<Int> =
    sequence {
        var a = 1
        var b = 1
        while (true) yield(a).also { a = b.also { b += a } }
    }

fun fibonacciNumbersLong(): Sequence<Long> =
    sequence {
        var a = 1L
        var b = 1L
        while (true) yield(a).also { a = b.also { b += a } }
    }

fun fibonacciNumbersBigInt(): Sequence<BigInteger> =
    sequence {
        var a = BigInteger.ONE
        var b = BigInteger.ONE
        while (true) yield(a).also { a = b.also { b += a } }
    }


/**
 * Returns an infinite sequence of all triangle numbers, starting with 1, 3, 6.
 *
 * The `i`-th triangle number is `1 + 2 + ... + i`.
 */
fun triangleNumbersInt(): Sequence<Int> = polygonalNumbersInt(3)

fun triangleNumbersLong(): Sequence<Long> = polygonalNumbersLong(3)

fun triangleNumbersBigInt(): Sequence<BigInteger> = polygonalNumbersBigInt(3.toBigInteger())

/**
 * Returns an infinite sequence of all [n]-gonal numbers, starting with 1, [n], ...
 *
 * For example, for [n] equals 3, this returns the triangle numbers: 1, 3, 6, 10, 15, ... The `i`-th triangle number is
 * `1 + 2 + ... + i`.
 *
 * And for [n] equals 4, this returns the square numbers: 1, 4, 9, 16, 25, ...
 */
fun polygonalNumbersInt(n: Int): Sequence<Int> =
    sequence {
        var sum = 1
        var step = n - 1
        while (true) {
            yield(sum)
            sum += step
            step += n - 2
        }
    }

fun polygonalNumbersLong(n: Long): Sequence<Long> =
    sequence {
        var sum = 1L
        var step = n - 1L
        while (true) {
            yield(sum)
            sum += step
            step += n - 2L
        }
    }

fun polygonalNumbersBigInt(n: BigInteger): Sequence<BigInteger> =
    sequence {
        var sum = BigInteger.ONE
        var step = n - BigInteger.ONE
        while (true) {
            yield(sum)
            sum += step
            step += n - BigInteger.TWO
        }
    }


/**
 * A sequence that changes monotonically, i.e. each value is always strictly greater than the last, or each value is
 * always strictly smaller than the last.
 */
interface MonotonicSequence<T : Comparable<T>> : Sequence<T> {
    /**
     * Returns the [index]th element in the [Sequence].
     */
    operator fun get(index: Int): T

    /**
     * Returns `true` if and only if the underlying [Sequence] eventually returns [element].
     */
    operator fun contains(element: T): Boolean
}

/**
 * Allows efficiently iterating and searching through an infinite [Sequence] of increasing values by caching
 * intermediate values.
 */
class CachedSequence<T : Comparable<T>>(base: Sequence<T>) : MonotonicSequence<T> {
    private val iterator = base.iterator()
    private val asList = mutableListOf<T>()
    private val asSet = mutableSetOf<T>()
    private lateinit var max: T


    override operator fun get(index: Int): T {
        require(index >= 0) { "Index must be non-negative." }

        while (index >= asList.size) step()

        return asList[index]
    }

    override operator fun contains(element: T): Boolean {
        if (asSet.isEmpty()) step()
        while (element > max) step()

        return element in asSet
    }

    /**
     * Iterates through the underlying sequence, using cached results where possible.
     */
    override fun iterator(): Iterator<T> =
        iterator {
            yieldAll(asList)

            var i = asList.size
            while (true) {
                if (i < asList.size) yield(asList[i])
                else yield(step())

                i++
            }
        }


    /**
     * Inserts (pre-calculated) values from [subsequence] into this cache.
     *
     * Requires that [subsequence] is a subsequence of [iterator], with [subsequence] and [iterator] having the same
     * first value, and [subsequence] not skipping any values generated by [iterator].
     */
    fun insert(subsequence: Collection<T>) {
        if (subsequence.isEmpty()) return
        if (::max.isInitialized && subsequence.max() <= max) return

        if (::max.isInitialized) asList.clear()
        asList += subsequence
        asSet += subsequence
        max = subsequence.max()
    }


    /**
     * Steps the sequence to the next element, and updates data structures where necessary.
     */
    private fun step(): T {
        val next = iterator.next()

        asList += next
        asSet += next
        max = next
        return next
    }
}

/**
 * Creates a [CachedSequence] from this [Sequence].
 */
fun <T : Comparable<T>> Sequence<T>.cached(): CachedSequence<T> = CachedSequence(this)
